package commands

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/spf13/cobra"

	"github.com/roylee17/zitadel-cli/internal/client"
	"github.com/roylee17/zitadel-cli/internal/output"
)

var patCmd = &cobra.Command{
	Use:   "pat",
	Short: "Manage Personal Access Tokens",
	Long:  "Commands for managing Personal Access Tokens (PATs) for users.",
}

var (
	patUserID         string
	patUsername       string
	patExpirationDays int
	patJWTKeyFile     string
	patJWTKeyString   string
)

var patListCmd = &cobra.Command{
	Use:     "list",
	Aliases: []string{"ls"},
	Short:   "List PATs for a user",
	RunE: func(_ *cobra.Command, _ []string) error {
		ctx, cancel := commandContext()
		defer cancel()

		userID, err := resolveUserID(ctx, patUserID, patUsername)
		if err != nil {
			return err
		}

		spin := output.NewSpinner("Fetching PATs...")
		spin.Start()

		pats, err := apiClient.ListPATs(ctx, userID)
		spin.Stop()
		if err != nil {
			return fmt.Errorf("failed to list PATs: %w", err)
		}

		if len(pats) == 0 {
			printer.Info("No PATs found for user")
			return nil
		}

		return output.PrintTable(printer, []string{"ID", "EXPIRATION"}, pats, func(p client.PAT) []string {
			return []string{p.ID, p.Expiration}
		})
	},
}

var patCreateCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a PAT for a user",
	Long: `Create a Personal Access Token for authentication.

Examples:
  # Create a PAT for a machine user (1 year expiration)
  zitadel-cli pat create --username iam-admin --expiration-days 365

  # Create a PAT with user ID
  zitadel-cli pat create --user-id 123456789 --expiration-days 90`,
	RunE: func(_ *cobra.Command, _ []string) error {
		ctx, cancel := commandContext()
		defer cancel()

		userID, err := resolveUserID(ctx, patUserID, patUsername)
		if err != nil {
			return err
		}

		spin := output.NewSpinner("Creating PAT...")
		spin.Start()

		pat, err := apiClient.CreatePAT(ctx, userID, patExpirationDays)
		spin.Stop()
		if err != nil {
			return fmt.Errorf("failed to create PAT: %w", err)
		}

		printer.Success("PAT created")
		printer.PrintKeyValue(map[string]string{
			"ID":         pat.ID,
			"Token":      pat.Token,
			"Expiration": pat.Expiration,
		})
		printer.Warning("IMPORTANT: Save this token now. It cannot be retrieved later!")

		return nil
	},
}

var patDeleteCmd = &cobra.Command{
	Use:   "delete <pat-id>",
	Short: "Delete a PAT",
	Args:  cobra.ExactArgs(1),
	RunE: func(_ *cobra.Command, args []string) error {
		if !confirmAction(fmt.Sprintf("Delete PAT '%s'?", args[0])) {
			printer.Info("Cancelled")
			return nil
		}

		ctx, cancel := commandContext()
		defer cancel()

		userID, err := resolveUserID(ctx, patUserID, patUsername)
		if err != nil {
			return err
		}

		spin := output.NewSpinner("Deleting PAT...")
		spin.Start()

		err = apiClient.DeletePAT(ctx, userID, args[0])
		spin.Stop()
		if err != nil {
			return fmt.Errorf("failed to delete PAT: %w", err)
		}

		printer.Success("PAT '%s' deleted", args[0])
		return nil
	},
}

// resolveUserID resolves user ID from either direct ID or username.
func resolveUserID(ctx context.Context, userID, username string) (string, error) {
	if userID != "" {
		return userID, nil
	}
	if username == "" {
		return "", fmt.Errorf("either --user-id or --username is required")
	}

	// Try human user first
	user, err := apiClient.GetUserByUsername(ctx, username)
	if err != nil {
		return "", fmt.Errorf("failed to find user: %w", err)
	}
	if user != nil {
		return user.ID, nil
	}

	// Try machine user
	machine, err := apiClient.GetMachineUserByUsername(ctx, username)
	if err != nil {
		return "", fmt.Errorf("failed to find machine user: %w", err)
	}
	if machine != nil {
		return machine.ID, nil
	}

	return "", fmt.Errorf("user '%s' not found", username)
}

// MachineKey represents the structure of a Zitadel machine key JSON file.
type MachineKey struct {
	UserID     string `json:"userId"`
	KeyID      string `json:"keyId"`
	PrivateKey string `json:"key"`
}

var patJWTCmd = &cobra.Command{
	Use:   "jwt",
	Short: "Generate PAT from machine key JWT",
	Long: `Generate a Personal Access Token (PAT) from a Zitadel machine key using JWT bearer grant.

This command:
  1. Reads a machine key JSON file (generated by Zitadel with ZITADEL_FIRSTINSTANCE_MACHINEKEYPATH)
  2. Creates a JWT token signed with the machine key
  3. Exchanges the JWT for an OAuth access token
  4. Uses the access token to create a PAT
  5. Outputs the PAT token to stdout

The machine key JSON should contain:
  - userId: The machine user ID
  - keyId: The key ID
  - key: The RSA private key in PEM format

Examples:
  # Generate PAT from machine key file
  zitadel-cli pat jwt --json-key-file ./management-api-key.json

  # Generate PAT from machine key JSON string
  zitadel-cli pat jwt --json-key-string '{"userId":"...","keyId":"...","key":"..."}'

  # With custom Zitadel URL
  zitadel-cli pat jwt --json-key-file ./key.json --url https://zitadel.example.com`,
	RunE: func(_ *cobra.Command, _ []string) error {
		// Validate that exactly one of the flags is set
		if patJWTKeyFile == "" && patJWTKeyString == "" {
			return fmt.Errorf("either --json-key-file or --json-key-string is required")
		}
		if patJWTKeyFile != "" && patJWTKeyString != "" {
			return fmt.Errorf("only one of --json-key-file or --json-key-string can be specified")
		}

		// Get Zitadel URL - use the same logic as root.go
		// zitadelURL is set by root.go's PersistentPreRunE from flags/env/config
		configCtx := cfg.CurrentCtx()
		var url string
		// Priority: flags > env > context config (same as root.go)
		if zitadelURL != "" {
			url = zitadelURL
		} else if envURL := os.Getenv("ZITADEL_URL"); envURL != "" {
			url = envURL
		} else if configCtx != nil && configCtx.URL != "" {
			url = configCtx.URL
		} else {
			return fmt.Errorf("zitadel URL required (--url, ZITADEL_URL, or configure context)")
		}

		// Read machine key
		var keyData []byte
		var err error
		if patJWTKeyFile != "" {
			keyData, err = os.ReadFile(patJWTKeyFile)
			if err != nil {
				return fmt.Errorf("read key file: %w", err)
			}
		} else {
			keyData = []byte(patJWTKeyString)
		}

		var machineKey MachineKey
		if err := json.Unmarshal(keyData, &machineKey); err != nil {
			return fmt.Errorf("parse machine key JSON: %w", err)
		}

		if machineKey.UserID == "" {
			return fmt.Errorf("machine key missing userId")
		}
		if machineKey.KeyID == "" {
			return fmt.Errorf("machine key missing keyId")
		}
		if machineKey.PrivateKey == "" {
			return fmt.Errorf("machine key missing key")
		}

		// Parse RSA private key
		privateKey, err := jwt.ParseRSAPrivateKeyFromPEM([]byte(machineKey.PrivateKey))
		if err != nil {
			return fmt.Errorf("parse private key: %w", err)
		}

		ctx, cancel := commandContext()
		defer cancel()

		// Step 1: Create JWT token
		spin := output.NewSpinner("Creating JWT token...")
		spin.Start()

		now := time.Now()
		claims := jwt.RegisteredClaims{
			Issuer:    machineKey.UserID,
			Subject:   machineKey.UserID,
			Audience:  jwt.ClaimStrings{url},
			IssuedAt:  jwt.NewNumericDate(now),
			ExpiresAt: jwt.NewNumericDate(now.Add(1 * time.Hour)),
		}

		token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
		token.Header["kid"] = machineKey.KeyID

		jwtToken, err := token.SignedString(privateKey)
		spin.Stop()
		if err != nil {
			return fmt.Errorf("sign JWT: %w", err)
		}

		// Step 2: Exchange JWT for access token
		spin = output.NewSpinner("Exchanging JWT for access token...")
		spin.Start()

		// Create a temporary client for OAuth (no PAT needed)
		oauthClient, err := client.New(client.Config{
			URL:      url,
			Token:    "", // Not needed for OAuth endpoint
			Insecure: insecure,
		})
		if err != nil {
			spin.Stop()
			return fmt.Errorf("create OAuth client: %w", err)
		}

		accessToken, err := oauthClient.ExchangeJWTForAccessToken(ctx, jwtToken)
		spin.Stop()
		if err != nil {
			return fmt.Errorf("exchange JWT for access token: %w", err)
		}

		// Step 3: Generate PAT token
		spin = output.NewSpinner("Generating PAT token...")
		spin.Start()

		// Default expiration: 2029-01-01 (as in the script)
		expirationDate := time.Date(2029, 1, 1, 0, 0, 0, 0, time.UTC).Format(time.RFC3339)

		pat, err := oauthClient.CreatePATWithAccessToken(ctx, accessToken, machineKey.UserID, expirationDate)
		spin.Stop()
		if err != nil {
			return fmt.Errorf("create PAT: %w", err)
		}

		// Output PAT token to stdout
		fmt.Fprintln(os.Stdout, pat.Token)

		return nil
	},
}

func init() {
	// List command flags
	patListCmd.Flags().StringVar(&patUserID, "user-id", "", "User ID")
	patListCmd.Flags().StringVar(&patUsername, "username", "", "Username")

	// Create command flags
	patCreateCmd.Flags().StringVar(&patUserID, "user-id", "", "User ID")
	patCreateCmd.Flags().StringVar(&patUsername, "username", "", "Username")
	patCreateCmd.Flags().IntVar(&patExpirationDays, "expiration-days", 365, "Days until expiration")

	// Delete command flags
	patDeleteCmd.Flags().StringVar(&patUserID, "user-id", "", "User ID")
	patDeleteCmd.Flags().StringVar(&patUsername, "username", "", "Username")

	// JWT command flags
	patJWTCmd.Flags().StringVar(&patJWTKeyFile, "json-key-file", "", "Path to machine key JSON file")
	patJWTCmd.Flags().StringVar(&patJWTKeyString, "json-key-string", "", "Machine key JSON as string")
	patJWTCmd.MarkFlagsMutuallyExclusive("json-key-file", "json-key-string")

	patCmd.AddCommand(patListCmd)
	patCmd.AddCommand(patCreateCmd)
	patCmd.AddCommand(patDeleteCmd)
	patCmd.AddCommand(patJWTCmd)
}
